<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Dynamic Connector</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            font-family: sans-serif;
            overflow: hidden;
        }

        #workspace {
            flex: 1;
            display: flex;
            justify-content: space-between;
            position: relative;
            padding: 0 60px;
        }

        #left-column,
        #right-column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            /* ✅ Vertical centering */
            align-items: center;
            gap: 12px;
            padding: 10px;
            position: relative;
            z-index: 1;
            min-height: 100vh;
            /* ✅ So they take up full vertical space */
        }

        .box {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 120px;
            padding: 10px 14px;
            min-height: 50px;
            background: #f1c40f;
            border: 2px solid #e67e22;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            user-select: none;
            cursor: pointer;
            white-space: nowrap;
        }

        #connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .line {
            stroke: black;
            stroke-width: 2;
            cursor: pointer;
            pointer-events: auto;
        }

        #connection-model {
            width: 240px;
            background: #f9f9f9;
            border-left: 1px solid #ccc;
            padding: 10px;
            font-size: 14px;
            overflow-y: auto;
        }

        #connection-model h3 {
            margin-top: 0;
            font-size: 16px;
        }

        .conn-entry {
            margin: 4px 0;
            font-family: monospace;
        }

        button {
            margin-top: 10px;
            padding: 6px 10px;
        }

        .box:focus {
            outline: 3px solid #3498db;
        }

        .box.selected {
            outline: 3px dashed #27ae60;
        }

        .runestone {
            width: 600px;
            max-width: 50%;
        }
    </style>
</head>

<body>

    <div id="workspace">
        <div id="left-column"></div>
        <svg id="connector-svg"></svg>
        <div id="right-column"></div>
    </div>


    <div id="connection-model">
        <h3>Connections</h3>
        <div id="conn-list"></div>
        <button onclick="gradeConnections()">Grade</button>
    </div>

    <script>

        const boxData = {
            left: [
                { id: "a", label: "Gravity" },
                { id: "b", label: "The Moon" },
                { id: "c", label: "A Black Hole" }
            ],
            right: [
                { id: "d", label: "A force that pulls" },
                { id: "e", label: "Orbits Earth" },
                { id: "f", label: "Nothing escapes" }
            ],
            correctAnswers: [
                ["a", "d"],
                ["b", "e"],
                ["c", "f"]
            ]
        };

        const leftColumn = document.getElementById('left-column');
        const rightColumn = document.getElementById('right-column');
        const svg = document.getElementById('connector-svg');
        const connList = document.getElementById('conn-list');
        const connections = [];
        const allBoxes = [];

        function createBox(id, label, role) {
            const div = document.createElement('div');
            div.className = 'box';
            div.dataset.id = id;
            div.dataset.role = role;
            div.textContent = label;
            div.tabIndex = 0;
            div.setAttribute('role', 'button');
            div.setAttribute('aria-label', `${role === "drag" ? "Draggable" : "Droppable"}: ${label}`);
            return div;
        }

        function getLabelById(id) {
            const item = [...boxData.left, ...boxData.right].find(box => box.id === id);
            return item ? item.label : id;
        }

        function getCenter(el) {
            const rect = el.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }

        function createLineElement(x1, y1, x2, y2) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", x1);
            line.setAttribute("y1", y1);
            line.setAttribute("x2", x2);
            line.setAttribute("y2", y2);
            line.setAttribute("class", "line");

            line.addEventListener("click", () => {
                svg.removeChild(line);
                const index = connections.findIndex(conn =>
                    (conn.fromBox === line.fromBox && conn.toBox === line.toBox) ||
                    (conn.fromBox === line.toBox && conn.toBox === line.fromBox)
                );
                if (index !== -1) connections.splice(index, 1);
                updateConnectionModel();
            });

            return line;
        }

        function isConnected(a, b) {
            return connections.some(conn =>
                (conn.fromBox === a && conn.toBox === b) ||
                (conn.fromBox === b && conn.toBox === a)
            );
        }

        function createPermanentLine(fromBox, toBox) {
            const fromRole = fromBox.dataset.role;
            const toRole = toBox.dataset.role;

            if (fromRole === toRole) {
                alert("You can only connect a draggable to a droppable.");
                return;
            }

            if (isConnected(fromBox, toBox)) return;

            const from = getCenter(fromBox);
            const to = getCenter(toBox);
            const line = createLineElement(from.x, from.y, to.x, to.y);

            line.fromBox = fromBox;
            line.toBox = toBox;

            svg.appendChild(line);
            connections.push({ fromBox, toBox, line });
            updateConnectionModel();

            const live = document.getElementById('aria-live');
            if (live) {
                live.textContent = `Connected ${fromBox.textContent} to ${toBox.textContent}`;
            }
        }

        function updateConnectionModel() {
            connList.innerHTML = "<strong>Connections:</strong><br>";
            connections.forEach(conn => {
                const fromLabel = conn.fromBox.textContent;
                const toLabel = conn.toBox.textContent;
                const line = document.createElement('div');
                line.className = 'conn-entry';
                line.textContent = `${fromLabel} → ${toLabel}`;
                connList.appendChild(line);
            });
        }

        function gradeConnections() {
            const actual = connections.map(conn => [
                conn.fromBox.dataset.id,
                conn.toBox.dataset.id
            ]);

            const results = [];

            boxData.correctAnswers.forEach(expected => {
                const found = actual.some(actualConn =>
                    actualConn[0] === expected[0] && actualConn[1] === expected[1]
                );
                results.push({ expected, correct: found });
            });

            const extraConnections = actual.filter(actualConn =>
                !boxData.correctAnswers.some(expected =>
                    expected[0] === actualConn[0] && expected[1] === actualConn[1]
                )
            );

            connList.innerHTML = "<strong>Grading:</strong><br>";
            let correctCount = 0;

            results.forEach(r => {
                const [fromId, toId] = r.expected;
                const fromLabel = getLabelById(fromId);
                const toLabel = getLabelById(toId);

                const line = document.createElement('div');
                line.className = 'conn-entry';
                line.textContent = `${fromLabel} → ${toLabel} ${r.correct ? "✅" : "❌"}`;
                connList.appendChild(line);

                if (r.correct) correctCount++;
            });

            if (extraConnections.length > 0) {
                const extraHeader = document.createElement('div');
                extraHeader.innerHTML = `<br><strong>Extra/Incorrect:</strong>`;
                connList.appendChild(extraHeader);

                extraConnections.forEach(([fromId, toId]) => {
                    const fromLabel = getLabelById(fromId);
                    const toLabel = getLabelById(toId);
                    const line = document.createElement('div');
                    line.className = 'conn-entry';
                    line.textContent = `${fromLabel} → ${toLabel} ❌`;
                    connList.appendChild(line);
                });
            }

            const scorePercent = Math.round((correctCount / boxData.correctAnswers.length) * 100);
            const scoreLine = document.createElement('div');
            scoreLine.innerHTML = `<br><strong>Score: ${scorePercent}%</strong>`;
            connList.appendChild(scoreLine);
        }

        // Box setup
        boxData.left.forEach(({ id, label }) => {
            const box = createBox(id, label, "drag");
            leftColumn.appendChild(box);
            allBoxes.push(box);
        });

        boxData.right.forEach(({ id, label }) => {
            const box = createBox(id, label, "drop");
            rightColumn.appendChild(box);
            allBoxes.push(box);
        });

        // Keyboard selection
        let selectedBox = null;

        allBoxes.forEach(box => {
            box.addEventListener("mousedown", e => {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    startBox = box;
                    const from = getCenter(startBox);
                    tempLine = createLineElement(from.x, from.y, from.x, from.y);
                    tempLine.setAttribute("stroke", "gray");
                    tempLine.setAttribute("stroke-dasharray", "4");
                    svg.appendChild(tempLine);

                    document.addEventListener("mousemove", updateTempLine);
                    document.addEventListener("mouseup", finishConnection);
                }
            });

            box.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    if (!selectedBox) {
                        selectedBox = box;
                        box.classList.add("selected");
                    } else {
                        if (box !== selectedBox) {
                            createPermanentLine(selectedBox, box);
                        }
                        selectedBox.classList.remove("selected");
                        selectedBox = null;

                        const currentIndex = allBoxes.indexOf(box);
                        const next = allBoxes[currentIndex + 1];
                        if (next) next.focus();
                        else allBoxes[0].focus();
                    }
                }
            });
        });

        function updateTempLine(e) {
            if (!startBox || !tempLine) return;
            const from = getCenter(startBox);
            tempLine.setAttribute("x1", from.x);
            tempLine.setAttribute("y1", from.y);
            tempLine.setAttribute("x2", e.clientX);
            tempLine.setAttribute("y2", e.clientY);
        }

        function finishConnection(e) {
            if (tempLine) {
                svg.removeChild(tempLine);
                tempLine = null;
            }

            const endBox = allBoxes.find(box =>
                box.contains(e.target) && box !== startBox
            );

            if (startBox && endBox) {
                createPermanentLine(startBox, endBox);
            }

            startBox = null;
            document.removeEventListener("mousemove", updateTempLine);
            document.removeEventListener("mouseup", finishConnection);
        }

        window.addEventListener("resize", () => {
            connections.forEach(conn => {
                const from = getCenter(conn.fromBox);
                const to = getCenter(conn.toBox);
                conn.line.setAttribute("x1", from.x);
                conn.line.setAttribute("y1", from.y);
                conn.line.setAttribute("x2", to.x);
                conn.line.setAttribute("y2", to.y);
            });
        });

    </script>
    <!-- for aria live announcements on making connections -->
    <div id="aria-live" style="position:absolute; left:-9999px;" aria-live="polite" aria-atomic="true"></div>
</body>

</html>