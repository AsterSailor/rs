<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Concept Connector</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: sans-serif;
            padding: 20px;
            margin: 0;
        }

        h2 {
            margin-bottom: 0.5em;
        }

        /* Main wrapper for each matching component */
        [data-component="matching"] {
            margin: 2rem 0;
        }

        .matching-workspace {
            display: flex;
            justify-content: space-between;
            position: relative;
            padding: 0 60px;
            max-width: 1000px;
            width: 100%;
            margin: 0 auto 1rem;
        }

        .left-column,
        .right-column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 12px;
            padding: 10px;
            position: relative;
            z-index: 1;
        }

        .box {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 120px;
            padding: 10px 14px;
            min-height: 50px;
            background: #f1c40f;
            border: 2px solid #e67e22;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            user-select: none;
            cursor: pointer;
            white-space: nowrap;
            text-align: center;
        }

        .box mjx-container {
            font-size: 1em;
        }

        .box:focus {
            outline: 3px solid #3498db;
        }

        .box.selected {
            outline: 3px dashed #27ae60;
        }

        .connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .line {
            stroke: black;
            stroke-width: 2;
            cursor: pointer;
            pointer-events: auto;
            transition: stroke 0.2s ease, stroke-width 0.2s ease;
        }

        .line.correct {
            stroke: green;
            stroke-width: 3;
        }

        .line.incorrect {
            stroke: #ccc;
            stroke-width: 1;
        }

        .line.highlighted {
            stroke: #e74c3c;
            stroke-width: 3;
        }

        .line.faded {
            stroke: #ccc;
            stroke-width: 1;
        }

        .conn-list {
            max-width: 800px;
            margin: 0 auto 1rem;
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 14px;
        }

        .conn-entry {
            margin: 4px 0;
            font-family: monospace;
        }

        button {
            display: inline-block;
            margin: 0.5rem;
            font-size: 1rem;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #3498db;
            color: white;
            cursor: pointer;
            transition: background 0.2s ease-in-out;
        }

        button:hover {
            background: #2980b9;
        }

        .aria-live {
            position: absolute;
            left: -9999px;
            top: auto;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }
    </style>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>

    <h2>Connect the Concepts</h2>
    <p>Match each concept on the left with its correct description on the right. Use your mouse or keyboard (Tab +
        Enter).</p>

    <div data-component="matching" id="matching-velocity1">
        <div class="matching-workspace">
            <div class="left-column"></div>
            <svg class="connector-svg"></svg>
            <div class="right-column"></div>
        </div>
        <div class="conn-list"></div>
        <button class="grade-button">Grade</button>
        <button class="reset-button">Reset</button>
        <div class="aria-live" aria-live="polite" aria-atomic="true"></div>
        <script type="application/json">
              {
                "left": [{ "id": "a", "label": "Energy: $E = mc^2$" },
                        { "id": "b", "label": "Kinetic energy: $KE = \\frac{1}{2}mv^2$" },
                        { "id": "c", "label": "Potential energy: $PE = mgh$" }],
                "right": [{ "id": "x", "label": "Mass-energy equivalence" },
                        { "id": "y", "label": "Energy of motion" },
                        { "id": "z", "label": "Energy due to position" }],
                "correctAnswers": [["a", "x"], ["b", "y"], ["c", "z"]]
              }
            </script>
    </div>

    <div data-component="matching" id="matching-velocity2">
        <div class="matching-workspace">
            <div class="left-column"></div>
            <svg class="connector-svg"></svg>
            <div class="right-column"></div>
        </div>
        <div class="conn-list"></div>
        <button class="grade-button">Grade</button>
        <button class="reset-button">Reset</button>
        <div class="aria-live" aria-live="polite" aria-atomic="true"></div>
        <script type="application/json">
              {
                "left": [{ "id": "a1", "label": "Energy: $E = mc^2$" },
                        { "id": "b1", "label": "Kinetic energy: $KE = \\frac{1}{2}mv^2$" },
                        { "id": "c1", "label": "Potential energy: $PE = mgh$" }],
                "right": [{ "id": "x1", "label": "Mass-energy equivalence" },
                        { "id": "y1", "label": "Energy of motion" },
                        { "id": "z1", "label": "Energy due to position" }],
                "correctAnswers": [["a1", "x1"], ["b1", "y1"], ["c1", "z1"]]
              }
            </script>
    </div>

    <div id="aria-live" aria-live="polite" aria-atomic="true"></div>

    <!-- Your app logic -->
    <script>
        class MatchingProblem {
            constructor(container, boxData) {
                this.container = container;
                this.boxData = boxData;
                this.workspace = container.querySelector('.matching-workspace');
                this.leftColumn = container.querySelector('.left-column');
                this.rightColumn = container.querySelector('.right-column');
                this.svg = container.querySelector('.connector-svg');
                this.connList = container.querySelector('.conn-list');
                this.ariaLive = container.querySelector('.aria-live');

                this.connections = [];
                this.allBoxes = [];
                this.selectedBox = null;
                this.startBox = null;
                this.tempLine = null;

                this.init();
            }

            init() {
                this.shuffle(this.boxData.left);
                this.shuffle(this.boxData.right);

                this.renderBoxes();
                this.attachEvents();

                if (window.MathJax && MathJax.typesetPromise) {
                    MathJax.typesetPromise();
                }
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            renderBoxes() {
                this.boxData.left.forEach(({ id, label }) => {
                    const box = this.createBox(id, label, "drag");
                    this.leftColumn.appendChild(box);
                    this.allBoxes.push(box);
                });

                this.boxData.right.forEach(({ id, label }) => {
                    const box = this.createBox(id, label, "drop");
                    this.rightColumn.appendChild(box);
                    this.allBoxes.push(box);
                });
            }

            createBox(id, label, role) {
                const div = document.createElement('div');
                div.className = 'box';
                div.dataset.id = id;
                div.dataset.role = role;
                div.innerHTML = label;
                div.tabIndex = 0;
                div.setAttribute('role', 'button');
                div.setAttribute('aria-label', `${role === "drag" ? "Draggable" : "Droppable"}: ${label}`);
                return div;
            }

            getCenter(el) {
                const elRect = el.getBoundingClientRect();
                const containerRect = this.workspace.getBoundingClientRect();
                return {
                    x: elRect.left - containerRect.left + elRect.width / 2,
                    y: elRect.top - containerRect.top + elRect.height / 2
                };
            }
            createLineElement(x1, y1, x2, y2) {
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", x1);
                line.setAttribute("y1", y1);
                line.setAttribute("x2", x2);
                line.setAttribute("y2", y2);
                line.setAttribute("class", "line");

                line.addEventListener("click", () => {
                    this.svg.removeChild(line);
                    const index = this.connections.findIndex(conn =>
                        (conn.fromBox === line.fromBox && conn.toBox === line.toBox) ||
                        (conn.fromBox === line.toBox && conn.toBox === line.fromBox)
                    );
                    if (index !== -1) this.connections.splice(index, 1);
                    this.updateConnectionModel();
                });

                return line;
            }

            isConnected(a, b) {
                return this.connections.some(conn =>
                    (conn.fromBox === a && conn.toBox === b) ||
                    (conn.fromBox === b && conn.toBox === a)
                );
            }

            createPermanentLine(fromBox, toBox) {
                const fromRole = fromBox.dataset.role;
                const toRole = toBox.dataset.role;

                if (fromRole === toRole) {
                    alert("You can only connect a draggable to a droppable.");
                    return;
                }

                if (this.isConnected(fromBox, toBox)) return;

                const from = this.getCenter(fromBox);
                const to = this.getCenter(toBox);
                const line = this.createLineElement(from.x, from.y, to.x, to.y);

                line.fromBox = fromBox;
                line.toBox = toBox;

                this.svg.appendChild(line);
                this.connections.push({ fromBox, toBox, line });
                this.updateConnectionModel();

                if (this.ariaLive) {
                    this.ariaLive.textContent = `Connected ${fromBox.textContent} to ${toBox.textContent}`;
                }
            }

            updateConnectionModel() {
                this.connList.innerHTML = "<strong>Connections:</strong><br>";
                this.connections.forEach(conn => {
                    const fromLabel = conn.fromBox.textContent;
                    const toLabel = conn.toBox.textContent;
                    const line = document.createElement('div');
                    line.className = 'conn-entry';
                    line.textContent = `${fromLabel} → ${toLabel}`;
                    this.connList.appendChild(line);
                });
            }

            gradeConnections() {
                const correctAnswers = this.boxData.correctAnswers;
                const actual = this.connections.map(conn => [
                    conn.fromBox.dataset.id,
                    conn.toBox.dataset.id
                ]);

                const correctMatches = correctAnswers.filter(expected =>
                    actual.some(given => given[0] === expected[0] && given[1] === expected[1])
                );

                const incorrectConnections = actual.filter(given =>
                    !correctAnswers.some(expected => expected[0] === given[0] && expected[1] === given[1])
                );

                const correctCount = correctMatches.length;
                const incorrectCount = incorrectConnections.length;
                const missingCount = correctAnswers.length - correctCount;
                const denominator = correctCount + incorrectCount + missingCount;
                const scorePercent = denominator === 0 ? 0 : Math.max(0, Math.min(100, Math.round((correctCount / denominator) * 100)));

                this.connections.forEach(conn => {
                    const idPair = [conn.fromBox.dataset.id, conn.toBox.dataset.id];
                    const isCorrect = correctAnswers.some(expected =>
                        expected[0] === idPair[0] && expected[1] === idPair[1]
                    );
                    conn.line.classList.remove("correct", "incorrect");
                    conn.line.classList.add(isCorrect ? "correct" : "incorrect");
                });

                this.connList.innerHTML = `<strong>Score: ${scorePercent}%</strong>`;
            }

            resetConnections() {
                this.connections.forEach(conn => {
                    if (conn.line && conn.line.parentNode === this.svg) {
                        this.svg.removeChild(conn.line);
                    }
                });
                this.connections.length = 0;
                this.updateConnectionModel();
                if (this.ariaLive) this.ariaLive.textContent = "All connections have been cleared.";
            }

            attachEvents() {
                this.allBoxes.forEach(box => {
                    box.addEventListener("mousedown", e => {
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            this.startBox = box;
                            const from = this.getCenter(this.startBox);
                            this.tempLine = this.createLineElement(from.x, from.y, from.x, from.y);
                            this.tempLine.setAttribute("stroke", "gray");
                            this.tempLine.setAttribute("stroke-dasharray", "4");
                            this.svg.appendChild(this.tempLine);

                            document.addEventListener("mousemove", this.updateTempLine);
                            document.addEventListener("mouseup", this.finishConnection);
                        }
                    });

                    box.addEventListener("keydown", e => {
                        if (e.key === "Enter") {
                            e.preventDefault();
                            if (!this.selectedBox) {
                                this.selectedBox = box;
                                box.classList.add("selected");
                            } else {
                                if (box !== this.selectedBox) this.createPermanentLine(this.selectedBox, box);
                                this.selectedBox.classList.remove("selected");
                                this.selectedBox = null;
                                const currentIndex = this.allBoxes.indexOf(box);
                                const next = this.allBoxes[currentIndex + 1];
                                if (next) next.focus();
                                else this.allBoxes[0].focus();
                            }
                        }
                    });

                    box.addEventListener("mouseenter", () => {
                        this.connections.forEach(conn => {
                            if (conn.fromBox === box || conn.toBox === box) {
                                conn.line.classList.add("highlighted");
                                conn.line.classList.remove("faded");
                            } else {
                                conn.line.classList.add("faded");
                                conn.line.classList.remove("highlighted");
                            }
                        });
                    });

                    box.addEventListener("mouseleave", () => {
                        this.connections.forEach(conn => {
                            conn.line.classList.remove("highlighted", "faded");
                        });
                    });
                });

                const gradeBtn = this.container.querySelector('.grade-button');
                const resetBtn = this.container.querySelector('.reset-button');
                if (gradeBtn) gradeBtn.addEventListener('click', () => this.gradeConnections());
                if (resetBtn) resetBtn.addEventListener('click', () => this.resetConnections());

                window.addEventListener("resize", () => {
                    this.connections.forEach(conn => {
                        const from = this.getCenter(conn.fromBox);
                        const to = this.getCenter(conn.toBox);
                        conn.line.setAttribute("x1", from.x);
                        conn.line.setAttribute("y1", from.y);
                        conn.line.setAttribute("x2", to.x);
                        conn.line.setAttribute("y2", to.y);
                    });
                });
            }

            updateTempLine = (e) => {
                if (!this.startBox || !this.tempLine) return;
                const from = this.getCenter(this.startBox);
                this.tempLine.setAttribute("x1", from.x);
                this.tempLine.setAttribute("y1", from.y);
                const containerRect = this.workspace.getBoundingClientRect();
                const x = e.clientX - containerRect.left;
                const y = e.clientY - containerRect.top;

                this.tempLine.setAttribute("x2", x);
                this.tempLine.setAttribute("y2", y);
            };

            finishConnection = (e) => {
                if (this.tempLine) {
                    this.svg.removeChild(this.tempLine);
                    this.tempLine = null;
                }

                const endBox = this.allBoxes.find(box => box.contains(e.target) && box !== this.startBox);
                if (this.startBox && endBox) this.createPermanentLine(this.startBox, endBox);

                this.startBox = null;
                document.removeEventListener("mousemove", this.updateTempLine);
                document.removeEventListener("mouseup", this.finishConnection);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('[data-component="matching"]').forEach(container => {
                const script = container.querySelector('script[type="application/json"]');
                if (script) {
                    try {
                        const boxData = JSON.parse(script.textContent);
                        new MatchingProblem(container, boxData);
                    } catch (err) {
                        console.error("Failed to parse boxData JSON:", err);
                    }
                }
            });
        });
    </script>




</body>

</html>